type treasury = 
 service {
   /// * Add a new price trigger condition
   ///    *
   ///    * Creates a failsafe rule that will pause tokens when price movements
   ///    * exceed the specified threshold within the time window.
   ///    *
   ///    * Only callable by admins with appropriate permissions.
   addTriggerCondition: (text, PriceDirection__1, float64, nat,
    vec principal) -> (Result_7);
   admin_executeTradingCycle: () -> (Result_1);
   admin_recoverPoolBalances: () -> (Result_6);
   admin_syncWithDao: () -> (Result_6);
   /// * Clear all trading pauses (emergency function)
   ///    *
   ///    * Removes all tokens from the trading pause registry.
   ///    * Only callable by master admins.
   clearAllTradingPauses: () -> (Result_2);
   /// * Clear all logs
   ///    * Only accessible by master admin or controller
   clearLogs: () -> ();
   /// * Clear price alerts log
   ///    *
   ///    * Removes all price alert history.
   ///    * Only callable by admins with appropriate permissions.
   clearPriceAlerts: () -> (Result);
   /// * Get current token allocations in basis points
   getCurrentAllocations: () -> (vec record {
                                       principal;
                                       nat;
                                     }) query;
   /// * Get the last N log entries
   ///    * Only accessible by master admin, controller, or DAO
   getLogs: (nat) -> (vec LogEntry) query;
   /// * Get the last N log entries for a specific context
   ///    * Only accessible by master admin, controller, or DAO
   getLogsByContext: (text, nat) -> (vec LogEntry) query;
   /// * Get the last N log entries for a specific level
   ///    * Only accessible by master admin, controller, or DAO
   getLogsByLevel: (LogLevel, nat) -> (vec LogEntry) query;
   /// * Get price alerts (paginated)
   ///    *
   ///    * Returns recent price alert events that triggered token pausing.
   ///    * Accessible by any user with query access.
   getPriceAlerts: (nat, nat) ->
    (record {
       alerts: vec PriceAlertLog;
       totalCount: nat;
     }) query;
   /// * Get price alerts for a specific token
   ///    *
   ///    * Returns price alert events for a particular token.
   ///    * Accessible by any user with query access.
   getPriceAlertsForToken: (principal, nat) -> (vec PriceAlertLog) query;
   /// * Get skip metrics and breakdown
   ///    * 
   ///    * Returns detailed information about skipped trades including:
   ///    * - Total skipped trades
   ///    * - Breakdown by skip reason
   ///    * - Skip rate as percentage of all attempts
   getSkipMetrics: () ->
    (record {
       skipBreakdown:
        record {
          insufficientCandidates: nat;
          noExecutionPath: nat;
          noPairsFound: nat;
          pausedTokens: nat;
          tokensFiltered: nat;
        };
       skipRate: float64;
       totalTradesSkipped: nat;
     }) query;
   /// * Get system rebalance parameters
   ///  *
   ///  * Returns all rebalancing configuration parameters that control the behavior
   ///  * of the Treasury including trading intervals, size limits, slippage tolerance, etc.
   ///  *
   ///  * Accessible by any user with query access.
   getSystemParameters: () -> (RebalanceConfig) query;
   /// * Get all token details including balances and prices
   getTokenDetails: () -> (vec record {
                                 principal;
                                 TokenDetails;
                               }) query;
   getTokenPriceHistory: (vec principal) -> (Result_5) query;
   /// * Get trading pause record for a specific token
   ///    *
   ///    * Returns the pause record if the token is paused from trading, null otherwise.
   ///    * Accessible by any user with query access.
   getTradingPauseInfo: (principal) -> (opt TradingPauseRecord__1) query;
   /// * Get detailed rebalancing status information
   ///    *
   ///    * Returns:
   ///    * - Current system status
   ///    * - Recent trade history
   ///    * - Portfolio valuation
   ///    * - Current vs target allocations
   ///    * - Performance metrics
   getTradingStatus: () -> (Result_4) query;
   /// * Get a specific trigger condition by ID
   ///    *
   ///    * Returns details of a single failsafe rule.
   ///    * Accessible by any user with query access.
   getTriggerCondition: (nat) -> (opt TriggerCondition) query;
   /// * List all tokens currently paused from trading
   ///    *
   ///    * Returns all tokens in the trading pause registry with their pause reasons.
   ///    * Accessible by any user with query access.
   listTradingPauses: () -> (TradingPausesResponse) query;
   /// * List all trigger conditions
   ///    *
   ///    * Returns all configured failsafe rules.
   ///    * Accessible by any user with query access.
   listTriggerConditions: () -> (vec TriggerCondition) query;
   /// * Manually pause a token from trading (for admin use)
   ///    *
   ///    * Allows admins to pause tokens from trading with a circuit breaker reason.
   ///    * Only callable by admins with appropriate permissions.
   pauseTokenFromTradingManual: (principal, text) -> (Result_2);
   /// * Process batch transfers from the DAO
   ///    *
   ///    * Handles both immediate and queued transfers of various token types.
   ///    * Only callable by DAO.
   ///    *
   ///    * tempTransferQueue - Array of transfer instructions
   ///    * Immediate - If true, process immediately and return block IDs
   ///    *
   receiveTransferTasks: (vec record {
                                TransferRecipient;
                                nat;
                                principal;
                                nat8;
                              }, bool) -> (bool,
    opt vec record {
              principal;
              nat64;
            });
   /// * Remove a trigger condition
   ///    *
   ///    * Deletes a failsafe rule permanently.
   ///    * Only callable by admins with appropriate permissions.
   removeTriggerCondition: (nat) -> (Result);
   /// * Reset the rebalancing state to initial values
   ///    *
   ///    * Completely resets all metrics, trade history, and timers
   ///    * Only callable by DAO or controller.
   resetRebalanceState: () -> (Result_1);
   /// * Set test mode (modifies safety parameters)
   ///    * Only callable by DAO.
   setTest: (bool) -> ();
   /// * Activate or deactivate a trigger condition
   ///    *
   ///    * Enables or disables a failsafe rule without deleting it.
   ///    * Only callable by admins with appropriate permissions.
   setTriggerConditionActive: (nat, bool) -> (Result);
   /// * Start the automatic rebalancing process
   ///    *
   ///    * Initializes the rebalancing engine, which will periodically:
   ///    * 1. Check current vs target allocations
   ///    * 2. Select tokens to trade
   ///    * 3. Execute trades on the best exchange
   ///    *
   ///    * Only callable by DAO or controller.
   startRebalancing: () -> (Result_1);
   /// * Stop the automatic rebalancing process
   ///    *
   ///    * Cancels all timers and sets the system to idle state
   ///    * Only callable by DAO or controller.
   stopRebalancing: () -> (Result_1);
   /// * Synchronize token details with DAO
   ///    *
   ///    * Updates token status from the DAO including:
   ///    * - Active/Inactive status
   ///    * - Paused/Unpaused state
   syncTokenDetailsFromDAO: (vec record {
                                   principal;
                                   TokenDetails;
                                 }) -> (Result_3);
   /// * Manually unpause a token from trading
   ///    *
   ///    * Removes a token from the trading pause registry, allowing it to trade again.
   ///    * Only callable by admins with appropriate permissions.
   unpauseTokenFromTrading: (principal) -> (Result_2);
   /// * Update the rebalancing configuration parameters
   ///    *
   ///    * Allows adjustment of trading intervals, sizes, and safety limits
   ///    * Only callable by DAO or controller.
   updateRebalanceConfig: (UpdateConfig, opt bool) -> (Result_1);
   /// * Update an existing trigger condition
   ///    *
   ///    * Modifies parameters of an existing failsafe rule.
   ///    * Only callable by admins with appropriate permissions.
   updateTriggerCondition: (nat, TriggerConditionUpdate) -> (Result);
 };
type UpdateConfig = 
 record {
   longSyncIntervalNS: opt nat;
   maxKongswapAttempts: opt nat;
   maxPriceHistoryEntries: opt nat;
   maxSlippageBasisPoints: opt nat;
   maxTradeAttemptsPerInterval: opt nat;
   maxTradeValueICP: opt nat;
   maxTradesStored: opt nat;
   minTradeValueICP: opt nat;
   portfolioRebalancePeriodNS: opt nat;
   priceUpdateIntervalNS: opt nat;
   rebalanceIntervalNS: opt nat;
   shortSyncIntervalNS: opt nat;
   tokenSyncTimeoutNS: opt nat;
 };
type TriggerPriceData = 
 record {
   actualChangePercent: float64;
   changeType: ChangeType;
   currentPrice: nat;
   maxPriceInWindow: nat;
   minPriceInWindow: nat;
   windowStartTime: int;
 };
type TriggerCondition__1 = 
 record {
   applicableTokens: vec principal;
   createdAt: int;
   createdBy: principal;
   direction: PriceDirection;
   id: nat;
   isActive: bool;
   name: text;
   percentage: float64;
   timeWindowNS: nat;
 };
type TriggerConditionUpdate = 
 record {
   applicableTokens: opt vec principal;
   direction: opt PriceDirection;
   isActive: opt bool;
   name: opt text;
   percentage: opt float64;
   timeWindowNS: opt nat;
 };
type TriggerCondition = 
 record {
   applicableTokens: vec principal;
   createdAt: int;
   createdBy: principal;
   direction: PriceDirection;
   id: nat;
   isActive: bool;
   name: text;
   percentage: float64;
   timeWindowNS: nat;
 };
type TransferRecipient = 
 variant {
   accountId: record {
                owner: principal;
                subaccount: opt Subaccount;
              };
   "principal": principal;
 };
type TradingPausesResponse = 
 record {
   pausedTokens: vec TradingPauseRecord;
   totalCount: nat;
 };
type TradingPauseRecord__1 = 
 record {
   pausedAt: int;
   reason: TradingPauseReason;
   token: principal;
   tokenSymbol: text;
 };
type TradingPauseRecord = 
 record {
   pausedAt: int;
   reason: TradingPauseReason;
   token: principal;
   tokenSymbol: text;
 };
type TradingPauseReason = 
 variant {
   CircuitBreaker: record {
                     reason: text;
                     severity: text;
                     triggeredAt: int;
                   };
   PriceAlert: record {
                 alertId: nat;
                 conditionName: text;
                 triggeredAt: int;
               };
 };
type TradingPauseError = 
 variant {
   NotAuthorized;
   SystemError: text;
   TokenAlreadyPaused;
   TokenNotFound;
   TokenNotPaused;
 };
type TradeRecord = 
 record {
   amountBought: nat;
   amountSold: nat;
   error: opt text;
   exchange: ExchangeType;
   slippage: float64;
   success: bool;
   timestamp: int;
   tokenBought: principal;
   tokenSold: principal;
 };
type TokenType = 
 variant {
   ICP;
   ICRC12;
   ICRC3;
 };
type TokenDetails = 
 record {
   Active: bool;
   balance: nat;
   epochAdded: int;
   isPaused: bool;
   lastTimeSynced: int;
   pastPrices: vec PricePoint;
   pausedDueToSyncFailure: bool;
   priceInICP: nat;
   priceInUSD: float64;
   tokenDecimals: nat;
   tokenName: text;
   tokenSymbol: text;
   tokenTransferFee: nat;
   tokenType: TokenType;
 };
type SyncErrorTreasury = 
 variant {
   NotDAO;
   UnexpectedError: text;
 };
type Subaccount = blob;
type Result_7 = 
 variant {
   err: PriceFailsafeError;
   ok: nat;
 };
type Result_6 = 
 variant {
   err: text;
   ok: text;
 };
type Result_5 = 
 variant {
   err: text;
   ok: vec record {
             principal;
             vec PricePoint__1;
           };
 };
type Result_4 = 
 variant {
   err: text;
   ok:
    record {
      executedTrades: vec TradeRecord;
      metrics:
       record {
         avgSlippage: float64;
         lastUpdate: int;
         skipBreakdown:
          record {
            insufficientCandidates: nat;
            noExecutionPath: nat;
            noPairsFound: nat;
            pausedTokens: nat;
            tokensFiltered: nat;
          };
         skipRate: float64;
         successRate: float64;
         totalTradesExecuted: nat;
         totalTradesFailed: nat;
         totalTradesSkipped: nat;
       };
      portfolioState:
       record {
         currentAllocations: vec record {
                                   principal;
                                   nat;
                                 };
         targetAllocations: vec record {
                                  principal;
                                  nat;
                                };
         totalValueICP: nat;
         totalValueUSD: float64;
       };
      rebalanceStatus: RebalanceStatus;
    };
 };
type Result_3 = 
 variant {
   err: SyncErrorTreasury;
   ok: text;
 };
type Result_2 = 
 variant {
   err: TradingPauseError;
   ok: text;
 };
type Result_1 = 
 variant {
   err: RebalanceError;
   ok: text;
 };
type Result = 
 variant {
   err: PriceFailsafeError;
   ok: text;
 };
type RebalanceStatus = 
 variant {
   Failed: text;
   Idle;
   Trading;
 };
type RebalanceError = 
 variant {
   ConfigError: text;
   LiquidityError: text;
   PriceError: text;
   SystemError: text;
   TradeError: text;
 };
type RebalanceConfig = 
 record {
   longSyncIntervalNS: nat;
   maxKongswapAttempts: nat;
   maxSlippageBasisPoints: nat;
   maxTradeAttemptsPerInterval: nat;
   maxTradeValueICP: nat;
   maxTradesStored: nat;
   minTradeValueICP: nat;
   portfolioRebalancePeriodNS: nat;
   rebalanceIntervalNS: nat;
   shortSyncIntervalNS: nat;
   tokenSyncTimeoutNS: nat;
 };
type PricePoint__1 = 
 record {
   icpPrice: nat;
   time: int;
   usdPrice: float64;
 };
type PricePoint = 
 record {
   icpPrice: nat;
   time: int;
   usdPrice: float64;
 };
type PriceFailsafeError = 
 variant {
   ConditionNotFound;
   DuplicateName;
   InvalidPercentage;
   InvalidTimeWindow;
   InvalidTokenList;
   NotAuthorized;
   SystemError: text;
 };
type PriceDirection__1 = 
 variant {
   Down;
   Up;
 };
type PriceDirection = 
 variant {
   Down;
   Up;
 };
type PriceAlertLog = 
 record {
   id: nat;
   priceData: TriggerPriceData;
   timestamp: int;
   token: principal;
   tokenSymbol: text;
   triggeredCondition: TriggerCondition__1;
 };
type LogLevel = 
 variant {
   ERROR;
   INFO;
   WARN;
 };
type LogEntry = 
 record {
   component: text;
   context: text;
   level: LogLevel;
   message: text;
   timestamp: int;
 };
type ExchangeType = 
 variant {
   ICPSwap;
   KongSwap;
 };
type ChangeType = 
 variant {
   CurrentToMax;
   CurrentToMin;
   MinToMax;
 };
service : () -> treasury
