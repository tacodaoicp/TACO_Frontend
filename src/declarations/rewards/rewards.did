type WithdrawalRecord = 
 record {
   amountSent: nat;
   caller: principal;
   fee: nat;
   id: nat;
   neuronWithdrawals: vec record {
                            blob;
                            nat;
                          };
   targetAccount: Account;
   timestamp: int;
   totalAmount: nat;
   transactionId: opt nat;
 };
type UserPerformanceResult = 
 record {
   aggregatedPerformance:
    record {
      allTimeICP: opt float64;
      allTimeUSD: opt float64;
      oneMonthICP: opt float64;
      oneMonthUSD: opt float64;
      oneWeekICP: opt float64;
      oneWeekUSD: opt float64;
      oneYearICP: opt float64;
      oneYearUSD: opt float64;
    };
   distributionsParticipated: nat;
   lastActivity: int;
   neurons: vec NeuronPerformanceDetail;
   "principal": principal;
   totalVotingPower: nat;
 };
type UserPerformanceGraphData = 
 record {
   aggregatedPerformanceICP: opt float64;
   aggregatedPerformanceUSD: float64;
   neuronData:
    vec
     record {
       checkpoints: vec CheckpointData;
       neuronId: blob;
       performanceScoreICP: opt float64;
       performanceScoreUSD: float64;
     };
   timeframe: record {
                endTime: int;
                startTime: int;
              };
 };
type TransferError = 
 variant {
   BadBurn: record {min_burn_amount: nat;};
   BadFee: record {expected_fee: nat;};
   CreatedInFuture: record {ledger_time: nat64;};
   Duplicate: record {duplicate_of: nat;};
   GenericError: record {
                   error_code: nat;
                   message: text;
                 };
   InsufficientFunds: record {balance: nat;};
   TemporarilyUnavailable;
   TooOld;
 };
type RewardsError = 
 variant {
   AllocationDataMissing;
   DistributionInProgress;
   InsufficientRewardPot;
   InvalidTimeRange;
   NeuronNotFound;
   NotAuthorized;
   PriceDataMissing: record {
                       timestamp: int;
                       token: principal;
                     };
   SystemError: text;
 };
type Rewards = 
 service {
   addToRewardSkipList: (neuronId: blob) -> (Result__1);
   admin_backfillDistributionHistory: (config: BackfillConfig) ->
    (Result__1_11);
   admin_recalculateAllIcpPerformance: () -> (Result__1);
   admin_recalculateIcpPerformanceForDistribution: (distributionId: nat) ->
    (Result__1);
   calculateNeuronPerformance: (neuronId: blob, startTime: int, endTime: 
    int, priceType: PriceType) -> (Result__1_10);
   calculateNeuronPerformanceQuery: (neuronId: blob, startTime: int, endTime:
    int, priceType: PriceType) -> (Result__1_10) composite_query;
   /// * Clear all logs
   clearLogs: () -> ();
   getAllNeuronRewardBalances: () -> (vec record {
                                            blob;
                                            nat;
                                          }) query;
   getAllWithdrawalHistory: (limit: opt nat) -> (Result__1_2);
   getAvailableBalance: () -> (nat);
   getBackfillStatus: () ->
    (record {
       currentPeriodEnd: int;
       currentPeriodStart: int;
       dataEndTime: int;
       dataStartTime: int;
       elapsedNS: int;
       inProgress: bool;
       lastErrors: vec text;
       periodsCompleted: nat;
       progressPercent: nat;
       startedAt: int;
       totalPeriods: nat;
     }) query;
   getCanisterStatus: () ->
    (record {
       daoId: principal;
       distributionStatus:
        record {
          inProgress: bool;
          lastDistribution: int;
          nextDistribution: int;
          totalDistributions: nat;
          totalRewardsDistributed: nat;
        };
       environment: text;
       neuronAllocationArchiveId: principal;
       priceArchiveId: principal;
     });
   getConfiguration: () ->
    (record {
       distributionEnabled: bool;
       distributionPeriodNS: nat;
       lastDistributionTime: int;
       maxDistributionHistory: nat;
       nextScheduledDistribution: opt int;
       performanceScorePower: float64;
       periodicRewardPot: nat;
       rewardPenaltiesCount: nat;
       rewardSkipListSize: nat;
       timerRunning: bool;
       totalDistributions: nat;
       votingPowerPower: float64;
     }) query;
   getCurrentDistributionStatus: () ->
    (record {
       currentDistributionId: opt nat;
       distributionEnabled: bool;
       inProgress: bool;
       lastDistributionTime: int;
       nextDistributionTime: int;
     }) query;
   getCurrentTotalNeuronBalances: () -> (nat) query;
   getDistributionHistory: (offset: nat, limit: nat) ->
    (record {
       hasMore: bool;
       records: vec DistributionRecord;
       total: nat;
     }) query;
   getDistributionsSince: (sinceTimestamp: int, limit: nat) ->
    (Result__1_9) query;
   getLeaderboard: (timeframe: LeaderboardTimeframe, priceType:
    LeaderboardPriceType, limit: opt nat, offset: opt nat) ->
    (vec LeaderboardEntry) query;
   getLeaderboardInfo: () ->
    (record {
       lastUpdate: int;
       leaderboardCounts:
        record {
          allTimeICP: nat;
          allTimeUSD: nat;
          oneMonthICP: nat;
          oneMonthUSD: nat;
          oneWeekICP: nat;
          oneWeekUSD: nat;
          oneYearICP: nat;
          oneYearUSD: nat;
        };
       maxSize: nat;
       totalDistributions: nat;
       updateEnabled: bool;
     }) query;
   /// * Get the last N log entries
   getLogs: (count: nat) -> (vec LogEntry) query;
   /// * Get the last N log entries for a specific context
   getLogsByContext: (context: text, count: nat) -> (vec LogEntry) query;
   /// * Get the last N log entries for a specific level
   getLogsByLevel: (level: LogLevel, count: nat) -> (vec LogEntry) query;
   getNeuronPerformance: (neuronId: blob) -> (Result__1_8) query;
   getNeuronRewardBalance: (neuronId: blob) -> (nat) query;
   getNeuronRewardBalances: (neuronIds: vec blob) ->
    (vec record {
           blob;
           nat;
         }) query;
   getRewardPenalties: () -> (Result__1_7) query;
   getRewardPenalty: (neuronId: blob) -> (Result__1_6) query;
   getRewardSkipList: () -> (Result__1_5) query;
   getTacoBalance: () -> (nat);
   getTotalDistributed: () -> (nat) query;
   getUserPerformance: (userPrincipal: principal) ->
    (Result__1_4) composite_query;
   getUserPerformanceGraphData: (userPrincipal: principal, startTime: 
    int, endTime: int) -> (Result__1_3) composite_query;
   getUserWithdrawalHistory: (limit: opt nat) -> (Result__1_2);
   getWithdrawalStats: () ->
    (record {
       totalRecordsInHistory: nat;
       totalWithdrawals: nat;
       totalWithdrawn: nat;
     }) query;
   getWithdrawalsSince: (sinceTimestamp: int, limit: nat) ->
    (Result__1_1) query;
   get_canister_cycles: () -> (record {cycles: nat;}) query;
   refreshLeaderboards: () -> (Result__1);
   removeFromRewardSkipList: (neuronId: blob) -> (Result__1);
   removeRewardPenalty: (neuronId: blob) -> (Result__1);
   setDistributionEnabled: (enabled: bool) -> (Result__1);
   setDistributionPeriod: (periodNS: nat) -> (Result__1);
   setMaxDistributionHistory: (max: nat) -> (Result__1);
   setPerformanceScorePower: (power: float64) -> (Result__1);
   setPeriodicRewardPot: (amount: nat) -> (Result__1);
   setRewardPenalties: (penalties: vec record {
                                         blob;
                                         nat;
                                       }) -> (Result__1);
   setRewardPenalty: (neuronId: blob, multiplier: nat) -> (Result__1);
   setRewardSkipList: (neuronIds: vec blob) -> (Result__1);
   setVotingPowerPower: (power: float64) -> (Result__1);
   startDistributionTimer: () -> (Result__1);
   startDistributionTimerAt: (targetTime: int) -> (Result__1);
   stopDistributionTimer: () -> (Result__1);
   triggerDistribution: () -> (Result__1);
   triggerDistributionCustom: (startTime: int, endTime: int, priceType:
    PriceType) -> (Result__1);
   updateLeaderboardConfig: (size: opt nat, enabled: opt bool) -> (Result__1);
   withdraw: (account: Account, neuronIds: vec blob) -> (Result);
 };
type Result__1_9 = 
 variant {
   err: RewardsError;
   ok: record {distributions: vec DistributionRecord;};
 };
type Result__1_8 = 
 variant {
   err: RewardsError;
   ok: NeuronPerformanceDetail;
 };
type Result__1_7 = 
 variant {
   err: RewardsError;
   ok: vec record {
             blob;
             nat;
           };
 };
type Result__1_6 = 
 variant {
   err: RewardsError;
   ok: opt nat;
 };
type Result__1_5 = 
 variant {
   err: RewardsError;
   ok: vec blob;
 };
type Result__1_4 = 
 variant {
   err: RewardsError;
   ok: UserPerformanceResult;
 };
type Result__1_3 = 
 variant {
   err: RewardsError;
   ok: UserPerformanceGraphData;
 };
type Result__1_2 = 
 variant {
   err: RewardsError;
   ok: vec WithdrawalRecord;
 };
type Result__1_11 = 
 variant {
   err: RewardsError;
   ok: BackfillResult;
 };
type Result__1_10 = 
 variant {
   err: RewardsError;
   ok: PerformanceResult;
 };
type Result__1_1 = 
 variant {
   err: RewardsError;
   ok: record {withdrawals: vec WithdrawalRecord;};
 };
type Result__1 = 
 variant {
   err: RewardsError;
   ok: text;
 };
type Result = 
 variant {
   Err: TransferError;
   Ok: nat;
 };
type PriceType = 
 variant {
   ICP;
   USD;
 };
type PriceInfo = 
 record {
   icpPrice: nat;
   timestamp: int;
   usdPrice: float64;
 };
type PerformanceResult = 
 record {
   allocationChanges: nat;
   checkpoints: vec CheckpointData;
   endTime: int;
   finalValue: float64;
   inTimespanChanges: vec NeuronAllocationChangeBlockData;
   initialValue: float64;
   neuronId: blob;
   performanceScore: float64;
   preTimespanAllocation: opt NeuronAllocationChangeBlockData;
   startTime: int;
 };
type NeuronReward = 
 record {
   checkpoints: vec CheckpointData;
   neuronId: blob;
   performanceScore: float64;
   performanceScoreICP: opt float64;
   rewardAmount: nat;
   rewardScore: float64;
   votingPower: nat;
 };
type NeuronPerformanceDetail = 
 record {
   distributionsParticipated: nat;
   lastAllocationChange: int;
   neuronId: blob;
   performance:
    record {
      allTimeICP: opt float64;
      allTimeUSD: opt float64;
      oneMonthICP: opt float64;
      oneMonthUSD: opt float64;
      oneWeekICP: opt float64;
      oneWeekUSD: opt float64;
      oneYearICP: opt float64;
      oneYearUSD: opt float64;
    };
   votingPower: nat;
 };
type NeuronAllocationChangeBlockData = 
 record {
   changeType: AllocationChangeType;
   id: nat;
   maker: principal;
   neuronId: blob;
   newAllocations: vec Allocation;
   oldAllocations: vec Allocation;
   penaltyMultiplier: opt nat;
   reason: opt text;
   timestamp: int;
   votingPower: nat;
 };
type LogLevel = 
 variant {
   ERROR;
   INFO;
   WARN;
 };
type LogEntry = 
 record {
   component: text;
   context: text;
   level: LogLevel;
   message: text;
   timestamp: int;
 };
type LeaderboardTimeframe = 
 variant {
   AllTime;
   OneMonth;
   OneWeek;
   OneYear;
 };
type LeaderboardPriceType = 
 variant {
   ICP;
   USD;
 };
type LeaderboardEntry = 
 record {
   distributionsCount: nat;
   lastActivity: int;
   neuronId: blob;
   performanceScore: float64;
   "principal": principal;
   rank: nat;
 };
type FailedNeuron = 
 record {
   errorMessage: text;
   neuronId: blob;
 };
type DistributionStatus = 
 variant {
   Completed;
   Failed: text;
   InProgress: record {
                 currentNeuron: nat;
                 totalNeurons: nat;
               };
   PartiallyCompleted: record {
                         failedNeurons: nat;
                         successfulNeurons: nat;
                       };
 };
type DistributionRecord = 
 record {
   actualDistributed: nat;
   distributionTime: int;
   endTime: int;
   failedNeurons: vec FailedNeuron;
   id: nat;
   neuronRewards: vec NeuronReward;
   neuronsProcessed: nat;
   startTime: int;
   status: DistributionStatus;
   totalRewardPot: nat;
   totalRewardScore: float64;
 };
type CheckpointData = 
 record {
   allocations: vec Allocation;
   maker: opt principal;
   pricesUsed: vec record {
                     principal;
                     PriceInfo;
                   };
   timestamp: int;
   tokenValues: vec record {
                      principal;
                      float64;
                    };
   totalPortfolioValue: float64;
 };
type BackfillResult = 
 record {
   endTime: int;
   errors: vec text;
   neuronsProcessed: nat;
   periodsCreated: nat;
   startTime: int;
   totalNeuronRewards: nat;
 };
type BackfillConfig = 
 record {
   clearExisting: bool;
   maxPeriods: nat;
   periodDays: nat;
   skipExistingPeriods: bool;
   startTime: int;
 };
type AllocationChangeType = 
 variant {
   FollowAction: record {followedUser: principal;};
   SystemRebalance;
   UserUpdate: record {userInitiated: bool;};
   VotingPowerChange;
 };
type Allocation = 
 record {
   basisPoints: nat;
   token: principal;
 };
type Account = 
 record {
   owner: principal;
   subaccount: opt vec nat8;
 };
service : () -> Rewards
